Project Portfolio: Software Testing & Quality Assurance
This repository contains portfolio artifacts demonstrating work in software testing, automation, and quality assurance. The files, including Contact.java, ContactService.java, ContactTest.java, ContactServiceTest.java, and the summary report, showcase the ability to create unit tests and apply appropriate testing strategies to meet requirements. The following paragraphs reflect on the key processes used during development.

To ensure that my code is functional and secure, I rely heavily on robust unit testing and input validation. Functionality is verified by creating test cases for every method, confirming that they correctly perform their intended operations, such as adding or updating a contact. Reliability and security are addressed by rigorously testing edge cases and invalid inputs, for example, checking for null values, data exceeding maximum length constraints, or attempts to use duplicate IDs. The code's internal validation logic is designed to prevent these issues from corrupting the system, which is a key measure against common software stability and security flaws.

Interpreting user needs and incorporating them into a program begins with carefully analyzing the requirements document. User needs are translated into technical constraints, such as defining that a contact's phone number must be exactly 10 digits or that a first name must not exceed 10 characters. I view these requirements as the direct definition of the necessary system behavior. I then incorporate these needs directly into the validation logic within the model classes, like Contact.java, and the service layer, like ContactService.java. This guarantees that the system enforces the user's data integrity expectations at every point of interaction.

My approach to designing software is structured around Object-Oriented Design (OOD) principles. I start by defining the core data object, such as the Contact class, which holds all the necessary data and establishes initial rules for data integrity using setters and constructors. Following this, I design a separate service class, for example, ContactService, which is responsible for managing the collection of these objects and enforcing higher-level business logic, like maintaining unique IDs and executing collection updates. Finally, I create separate Unit Test classes for both the model and the service. These automated tests act as a final specification, providing proof that the design adheres to the stated requirements and behaves reliably across all potential scenarios.
